# 리팩토링 정의

## 2.1 정의
앞에서 제시한 정으를 따르면 특정한 방식에 따라 코드를 정리하는 껏만이 리팩터링이다.
리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 
이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다.

개별 리팩터링은 그 자체로 아주 작을 수도 있고,
작은 단계 여러 개가 합쳐진 모습일 수도 있다.

따라서 리팩터링하는 동안에는 코드가 항상 정상작동하기 때문에 전체 작업이 끝나지 ㅇ낳았더라도 언제든 멈출 수 있다.

| 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다."라고 한다면, 십중팔구 리팩터링한 것이아니다.

나는 코드베이스를 정리하거나 구조를 바꾸는 모든 작업을 재구성"Restructuring"이라는 포괄적인 용어로 표현하고
리팩터리은 재구성중 특수한 한 형태로 본다.

한번에 바꿀 수 잇는 작업을 숨낳은 단계려 잘게 나눠서 작업하는 모습을 처음 접하명 리팩터링하는것이 오히려 비효율적이ㄹ라고 생각하ㄱ 쉽다.
하지만 이렇게 잘게 나눔으로써 오히려 작업을 더 발리처리할 수 있다.
단계들이 체계적으로 구성되어 있기도 하고, 무엇보다 디버깅하는데 시간을 뺏기지 않기 때문이다.

앞에서 리팩터링을 정의할 떄 겉보기 동작"이란 표현을 썼다.
일부러 두리뭉실하게 표현했는다.
리팩터링하기 전과 후의 코드가 똑깥이 동작해야 한다는 뜻이다.
그렇다다고 완정히 똑같다는 말은 아니다.
가령 함수 추출하기 를 거치면 콜스택이 달라쟈서 
성능이 변할 수 있다.
그렇다 해도 사용자 관점에서는 달라지는점이 없어야 한다.
특히 함수 선어 바꾸기나 함수 옮기기 같은 리팩터링을 하면 모듈의 인터페이스가 바뀔 때가 많다.
### 한편, 리팩터링과정에서 발견된 버그는 리팩터링 후에도 그대로 남아있어야한다.
단 아무도 발견하지 못한 숨은 버그는수정해도된다.

리팩터링은 성능 최적화와 비슷하다.
둘 다 콛드를 변경하지만, 프로그램의 저전반적인 기능은 그 대로 유지한다.
단지 목적이 다를 뿐이다.

리팩터링의 목저은 코드를 이해하고 수정하기 수ㅐㅔㅂ가 만드는 것이다.

프로그램 성능은 좋아질 수도 나빠질 수도 있다.

반면 성능 최적화는 오로지 속도 개선에만 신경쓴다.

그래서 모표성능에 반드시 도달해야한다면 코드는 다루기에 더 어렵게 바뀔 수도 있음을 각오ㅇ해야하낟.

## 2.2 두 개의 모자.
나는 소프트웨어를 개발할 떄 모적이 '기능 추가'냐 아니면 '리팩터링'이냐를 명화히 구분해 작업한다.

켄트 벡은 이를 2개의 모자 에 비유했다.
기능을 추가할 떄는 기능 추가 모자를 쓴다음 기존 코드는 절대 건드리지 ㅇ낳고 새 기능을 추가하기만 한다.
진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정한다.

반면 리팩터링할 떄ㅔ는 '리팩터링'모자를 쓴다음 
기능추가는 절대 하지 ㅇ낳기로 다짐한 뒤 오로지 코드 재구성에만 전념한다.
앞과정에서 놓친 데트스 켕이스를 발견하지 ㅇ낳는 한, 테스트도 새로 만들지 ㅇ낳는다.
부득이 인터페이스를 변경해야할 ㅒㄸ만 기존 테스틑를 수정한다.


소프트웨어를 개발하는 동안 나는 두 모자를 자주 바꿔 쓴다.
새 기능을 추가하다 보면 코드 구조를 바꿔야 작업하기 훨씬 쉽ㄱㅆ다는 생까이 들기도 하는데,
그러면 잣ㅁ시 모자를 바꿔 쓰고 리팩터링한다.
코드 구조가 어느정도 개선되면, 다시 모자를 바꿔쓰고 기능 추가를 이어간다.
추가한 기능이 제대로 작동하는 지까지 확인했다면 작성한 코드를 살펴본다.
코드가 이해하기 어렵게 짜였다면, 다시 모ㄷ자를 바꿔쓰고 리팩터링한다.
전체 작업 시간이 10분 정도로 짧다 해도, 항상 내가 쓰고 잇는 모자가 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야한다.

** 전체 작업시간이 10분 정도로 짧다 해도, 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 한다. **

## 2.3 리팩터링하는 이유

리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 절대아니다.
하지만 코드를 건강한 상태로 유지하는데 도와주는 약임은 분명하다.
리팩터링은 다양한 용도로 활용할 수 있고, 또 받ㄴ드시 그래야하는 도구다.

### 리팩터링하면 소프트웨어 설계가 좋아진다.
리팩터링하지 않으면 소프트웨어의 내부 설계(아키텍처)가 썩기 쉽다.
아키텍터를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.
그러면 모드만 봐서는 설계를 파악하기 어려워진다.
코드 구조가 무너지기 시작하면 악효과가 누적된다. 
코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워지고, 설계가 부패되는 속도는 더욱 빨라진다.
반면 규칙적인 리팩터링은 코드의 구조를 찌탱해줄 것이다.

같은 일이을 하더라도, 설계가 나쁘면 코드가 길어지기 십상이다.
사실상 같은 일을 하는 코드가 여러 곳에 나타날 수 있기 때문이다.
그래서 중복 코드 제거는 설계 개선 작업의 중요한 한 죽을 차지한다.

코드량을 줄인다고 시스템이 빨라지는 것은 아니다. 프로그램의 용량이 속도에 영향을 주는 경우는 별로 없다.
하지만 코드량이 줄면 수정하는데 드는 노력은 크게 달라진다.
코드가 길수록 실수 없기 수정하기 어려워진다.
이해해야 할 코드량도 늘어난다.
비슷한 일을 하는 코드가 산재해있다면ㅇ 하 부부만 살짝 붜써서는 시스템이 예상되로 작동하지 ㅇ낳을 수 있다.
반면 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 조방할 수 있으며 이는 바람직한 걸꼐의 핵심이다.

| 아직까지 읽으면서 드는 생각 응ㄴ 빨리 1장의 코드 예제를 다시 복습하면서 몸에 조긍ㅁ이라도 익회고 내 프로젝트 코드에 녹이고 싶다 는 마음 뿐이다.

### 리팩터링하면 소프트웨어를 이해하기 쉬워진다.
프로그래밍은 여러 면에서 마치 컴퓨터와 대화하는 것과 같다.
컴퓨터에게 시킬 일읖 표현하는 코드를 작성하면 컴퓨터는 정확히 시킨 대로 반응한다.
그래서 컴퓨터에게 시키려는 일과 표현한 코드의 차이를 최대한 줄여야한다.
프로그래밍은 결국 내가 원하는 바를 정화힉 ㅠㅛ구현하는 일이다.

그런데 내 소스 코드를 컴퓨터만 사용하는게 아니다.
예컨대 몇 달이 지나 누군가 내 코드를 수정하고자 읽게 될 수 있다.
사실 프로그램ㅇ에서 사람이 가장 중요하지만 소홀하기 쉽다.
코드를 컴파일하는데 시작인 살짝 더 걸린다고 누가 모뤄하겠는가?
하지만 다름 프로그램가 내 코드를 제대로 이해했담면, 한 시간에 끝낼 수정을 일주일이나 절린다면 사정이 달라진다.

문제는 프로그램을 동작시키는데만 신경쓰다보ㅓ면, 나중에 그 코드를 다룰 개발자를 배려하ㄴ지 못한다는데 있다.
코드를 이해하기 쉽게 만들려면 일하는 리듬에 변화를 줘야한다.
리팩토링은 코드를 더 잙 잃히게 도워준다.
잘 작동하지만 이상적인 구조는 아닌 코드가 이싸면 꼭 시간을 내서 리팩터링해보자.
그러면 코드의 목적이 더 잘 드러나게 다시말해 내 의도를 명확하게 전달하도록 개선할 수 있다.

단지 다른 사람을 배려하기우ㅐㅎ서가 아니다.
사실 그 다른사람이 바로 나 자신일 때가 많다. 그래서 더더욱리팩터링이 중요하다.
난 굉장히 게으른 프로그래머다. 단적인 에로 내가 작성한 코드를 전혀 머리에 담아두지 ㅇ낳는다.
다시 말해 코드를 보면 알 수 있는 것들은 의도적으로 기억하지 않는다.
내 기억 용량으 초과할까봐 두렵기 때문이다.그래서 기억할 피룡가 있는것들은 최대한 코드에 담으려고한다.
그러면 모띠드맥주가 ㅇ뇌세포를 파괴하더라도 걱정할 필요가 없다.

| 프로그래밍을 결국 내가 원하는바를 정화힉 구현하는 일이다. 
| 잘 읽히는 코드 = 내 의도가 명확히 드러나는 코드 = 내 목적이 잘 보이는 코드


### 리팩터링하면 버그를 쉽게 찾응 ㄹ수 있다.
코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 한다.
솔직히 나는버그를 차ㅈ는데 뛰어난 편은 아니다.
코드를 주욱 읽고는 금세 버그를 찾아내는 사람도 있는데, 난 그렇게 못한다.
하지만 리팩터링하면 코드가 하는일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다.
프로글매의 구조를 명확하게 다ㅇ듬으면 그냥 이럴것이다.'라고 가정하더 점들이 분명히 드러나느데, 버그를 지나치려야 지나칠 수없을 정도까지 명확해진다.
이 사실은 케트 벡의 말을 떠올기ㅔ 해준다.
"난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습과능ㄹ 지닌 괜ㅊ낳은 프로그래머일 뿐이에요" 
리팩터링은 견고한 코드를 작성하는데 무첮 효과적이다.



| 코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 한다.

