프로그램이 잘 작동하는 상황에서 그저 코드가 '지저분하다'는 이유로
불평하는 것은 프로글매의 구조를 너무 미적이니 기준으로만 판단하는 건 아닐까?

컴파일러는 코드가 깔끔하든 지저분하든 개의치 않으니말이다.
하지마느 그 코드를 수저하려면 사람이 개입되고, 사람은 코드의 미적상태에 민감하다.

설계가 나쁜 시스템은 수정하기 어렵다.
원하는동작을 수행하도록 하기 위해 수정해야햘 부분을 찾고, 기존 코드와 잘 맞물려 작동하게 할 방법을 강구하기가 어렵기 때문이다.
무엇을 수정할지 찾기 어렵다면 실수를 저질러서 버극가 생길 가능성도 높아진다.

그래서 나는 수백줄짜리 코드를 수정할 때면 먼저 프로그램의 작동 방식을 더 쉽게 파악할 수 있도록 ㅋ
코드를 여러 함수와 프로글매 요소로 재구성한다.
프로그램의 구조가 빈약하다면 대체로 구조부터 바로잡은 뒤에 
기능을 수정하는 펴ㄴ이 작업하기가 훨씬 수월하다.

프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 위운 형채로 리팩터링하고나서 우너하는 기능을 추가한다.

수정할 부분을 발견
청구 내역을 HTML로 출력하는 기능이 피료하다.

이 변경이 어느 부분에 영향을 줄지 생각해보자.
우선 HTML 태그를 삽입해야하니
청구 결과에 문자열을 추가하는 문장 각각을 조건문으로 감싸야한다.
그러면 statement함수의 복잡도가 크게 증가하다.
이런 상황이라면
대부분 이 함수의 복사본을 만들고 본사본에서 HTML출력하는 식으로 처리할 것이다.

이때 복사하는 일 자체는 그리 부담되지 ㅇ낳지만, 나중에 수많은 문제를 일으킬 여지가 있다.
청구서 작성 로직을 변경할 떄마다 기존 함수와 HTML qjwjs gkatn ahen tnwjdgkrh, gkdtl dlfrhksehlrp tnwhdgoTsmswleh ghkrdlsgodigksek.
로직을 변경할 일이 절대 없다면 이렇게 복사해서 붙이는 방식도 상관없지만,
오래 사용할프로그램이라면, 중복 코드는 골칫거리가 된다.

이는 주 번째 변경 사항과도 관련이 있다.
배우들은 사극 전원극, 전원 희극, 역사 전웍극, 역사 비극, 희비 역사 전원극, 장면 변화가 없는 고전극
길이와 시잔과 장소에 제약없는 자유극 등 
더 많은 장르를 연기하고 싶어한다.
언제 어떤 연극ㄱ을 할지 아직 결정하지 못했지잠,ㄴ 이 변경은 공연료와 적립 포인트 계산법에 영향을 줄것이다.

경험 많은 개발자로서 내가 장담하건대, 어떤 방식으로ㄷ 정하든 반드시 6개월 안에 다시 변경하게 될 것이다.
새로운 요구사항은 수색 대원처럼 한두명씩이 아니라, 한 부대씩 몰려오기 마련이다.

이처럼 연극 장르롸 공연료 정책이 달라질 때마다 statement함수를 수정해야한다.
만약 statement를 복사해서 별도읜 htmlStatement를 만든다면 모든 수정이 두 함수에 일관되게 방영되도록 보장해야한다.
게다가 정책이 복잡해질 수록 수정할 부분을 찾기 어려워지고 수정과정에서 실수할 가능성도 커진다.

리팩터링이 필ㅇ여ㅛ한 이유는 바로 이러한 변경 때문이다.
잘 작동하고 나중에 변경할 일이 절대 없다면,코드를 나둬도 문제가 없다.

## 1.3 리팩터링의 첫 단계

리팩터링의 첫 단계는 항상 똑같다. 
리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드들부터 마련해야한다.
리팩터링에서 테스트의 역할은 괸장히 중요하다.
리팩터링 기법들이 버그발생 여지를 최소화하도록 구성됐다고는 하나 실제 작업은 사람이 수행하기 때문에 언제든 실수할 수 있다.
프로그램이 커질 수록 수정과정에서 예상치 못한 문제가 발생할 가능성이 크다.
"디지털 시대의 연약한 자여, 그대 이름은 소프트웨어'

statement함수의 테스트는 어떻게 구성하면 될까? 
이 함수가 문자열을 반환하므로, 다양한 장르의 공연들로 구성된 공연료 청구서 몇 개를 미리 작성하여 문자열 형태로 준비해둔다.
그런 다음 statement가 반환한 문자열과 준비해둔 정ㅈ땁 문자열을 비교한다.
그리고 테스트 프레임워크를 ㅣ용하여 모든 테스트를 단추키 하나로 실행할 수 있도록 설정해둔다.
이 테스트는 몇 초면 끝날 것이며, 나중에 보겠지만, 나는 테스트를 수시로한다.

여기서 중요한 부분은 테스트 결과를 보고하는 방식이다.
출력된 문자열이 정답 문자열과 똑같다면, 테스트를 통과했다는의의 초록불을 켜고,
조금이라도 다름녀 실패를 뜻하는 빨간불을 켠다.
즉, 성공/실패를 스스로 판단하는 자가진단 테ㅅ트로 만든다.
자가진단 여부는 매우 중요하다.
그렇지 않으면 테스트 결곽를 노트에 적어둔 값과 일일이 누능로 비교해야하는데
속도가 상당히 떨어지게 된다.
최신 테스트 프레임워크는 자가진단 테스트를 작성하고 실행하는데 필요한 모든 기능을 제공한다.

"리팩터링하기 전에 제대로된 테스트부터 마련한다. 테스틑는 반드시 자가진단하도록 만든다."

나는 리팩터링 시 ㅍ테스트에 상당히 의지한다.
내가 저지른 실수로부터 보호ㄹ해주는 버그 검추기역할을 해주기 ㄷ때무니다.
원하는 ㅐ용을 소스코드와 테스트 코드 양쪽에 적어줌ㄴ, 두번 다다 똑같이 씰수하지 않는 한 버그 검추기에 반드시 걸린다.
이와같이 중복 검사롤 실ㅅ 가능성을 크게 줄일 숭 ㅣㅆ다.
테스트를 작성하는데 시간이 좀 걸맂만, 신경써서 만들어두면 디버깅 시간이 줄어들어 전체 가업 시간은 오히려 단추된다.
리팩터리에서 테스트의 역할이 굉장히 중요하기 때문에 4장 전체를 테스트레 할애했다.

## 1.4 statemet() 함수 쪼개기

statement처럼 긴 함수를 리팩터링 할 때는 먼저 저체 동작을 각각의 부분으로 나눌 수 있는 지점을 찾는다.
그러면 중간 즈음의 ㄴ쟛초 문이 가장 먼저 눈에 띌 것이다.


## 1.8 다형성을 활요ㅇ해 셰산 코드 재구성하기
이버넹는 여극 장르를 추가하고 싶다.
장르마다 공ㅇ연료와ㅏ 적립 포아니트 계산법을 다르게 지정하도록 기능을 수정해보자,.
현재 상태에서 코드를 변겯ㅇ하려면 이 계산을 수행하는 함수에서 조건문을 수정해야한다.
amountFor함수를 보면 연극 장르에 다라 계산 방식이 달라진다는 사실을 알 수 있는데,
이런 형태의 조건부 로직은 코드 수정횟수가 늘어날 수록 골칫거리로 전락하기 수빈다.

이를 방지하려면 프로그램언어가 제공하는 구조겆인 요솔 적절히 보완해야한다.

조건부 로직은 명화학ㄴ 주고로 본환하는 방법은 다얀하지만, 여기서는 객체지향의 핵심특성인 다형성을 활용하는 것이 자연스럽다.
자바스크릡트 커뮤니티에서 전ㄷ통적인 객ㅊ레지향지원은 오랫동안 논란거리였다
그러다가 es6부터 객체지향을 사용할 수 있는 문법과 구조가 제대로 지원되기 시작해땃.
따라서 딱 맞는 상황이라면 이런 시능을 적극 활용하는 것이 좋다.
바로 지금

이번 자겅ㅂ의 모표는 상속 계층을 구성해서 희극 서브클래스와 비극 서브 클래스가 각자의 궃[적인 계산 로직을 정의하는 것이다.]
호출하는 쪽에서는 다형성 버전읜 공연료 꼐산 함수를 호ㅜㄹ하기만 하면되고, 희극이냐 비극이냐에 따라 정확한 계산 로직을 견련하는 작업은 언어 차원에서처리해준다.

적립 포인트 계산도 비슷한 구조로 만들 것이다.
이 관정에서 몇 가지 리팩터링 기법을 적용하는데, 그중 핵심은 조건부 로직은 다형성으로 바꾸기이다.

이 리팩터링은 고전부 ㅗ드 한 덩어리를 다형성으로 활용하는 방식으로 바ㄷ꿔준다.
그런데 이 리팩터링을 적용하려면 상속 계층부터 정의해야하낟.
즉 공열ㄴ료와 적립 포인트 계산 함수를 담을 클래스가 필여ㅛ한다.

먼저 계산을수ㅐㅎㅇ하는 코들르 살펴보자.

|| 앞에서 수행한 리팩리ㅏㅇ 벋분에 출력 데이터 구졸르 수정하지 않는 한 출력 포맷 관련 코드에ㅅ는 신경쓸이일이 없다.
 더 확실하게 하려면 중간 데이터 구조를 검사흔ㄴ 테스트를 추가한다.

 